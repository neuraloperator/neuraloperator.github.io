
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/models/plot_UNO_darcy.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_models_plot_UNO_darcy.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_models_plot_UNO_darcy.py:


U-NO on Darcy-Flow
==================

Training a U-shaped Neural Operator (U-NO) on the small Darcy-Flow example we ship with the package.

This tutorial demonstrates the U-NO architecture, which combines the resolution invariance
of neural operators with the multi-scale feature extraction of U-Net architectures.
The U-NO uses skip connections and multi-resolution processing to capture both local
and global features in the data, making it particularly effective for complex PDE problems.

.. GENERATED FROM PYTHON SOURCE LINES 15-22

.. raw:: html

   <div style="margin-top: 3em;"></div>

Import dependencies
-------------------
We import the necessary modules for working with the UNO model

.. GENERATED FROM PYTHON SOURCE LINES 22-36

.. code-block:: Python


    import torch
    import matplotlib.pyplot as plt
    import sys
    from neuralop.models import UNO
    from neuralop import Trainer
    from neuralop.training import AdamW
    from neuralop.data.datasets import load_darcy_flow_small
    from neuralop.utils import count_model_params
    from neuralop import LpLoss, H1Loss

    device = "cpu"









.. GENERATED FROM PYTHON SOURCE LINES 37-44

.. raw:: html

   <div style="margin-top: 3em;"></div>

Loading the Darcy-Flow dataset
------------------------------
We load the Darcy-Flow dataset for training and testing.

.. GENERATED FROM PYTHON SOURCE LINES 44-53

.. code-block:: Python


    train_loader, test_loaders, data_processor = load_darcy_flow_small(
        n_train=1000,
        batch_size=32,
        n_tests=[100, 50],
        test_resolutions=[16, 32],
        test_batch_sizes=[32, 32],
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Loading test db for resolution 16 with 100 samples 
    Loading test db for resolution 32 with 50 samples 




.. GENERATED FROM PYTHON SOURCE LINES 54-68

.. raw:: html

   <div style="margin-top: 3em;"></div>

Creating the U-NO model
------------------------
We create a U-shaped Neural Operator with the following architecture:

- in_channels: Number of input channels
- out_channels: Number of output channels
- hidden_channels: Width of the hidden layers
- uno_out_channels: Channel dimensions for each layer in the U-Net structure
- uno_n_modes: Fourier modes for each layer (decreasing then increasing)
- uno_scalings: Scaling factors for each layer

.. GENERATED FROM PYTHON SOURCE LINES 68-90

.. code-block:: Python


    model = UNO(
        in_channels=1,
        out_channels=1,
        hidden_channels=64,
        projection_channels=64,
        uno_out_channels=[32, 64, 64, 64, 32],
        uno_n_modes=[[8, 8], [8, 8], [4, 4], [8, 8], [8, 8]],
        uno_scalings=[[1.0, 1.0], [0.5, 0.5], [1, 1], [2, 2], [1, 1]],
        horizontal_skips_map=None,
        channel_mlp_skip="linear",
        n_layers=5,
    )

    model = model.to(device)

    # Count and display the number of parameters
    n_params = count_model_params(model)
    print(f"\nOur model has {n_params} parameters.")
    sys.stdout.flush()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    fno_skip='linear'
    channel_mlp_skip='linear'
    fno_skip='linear'
    channel_mlp_skip='linear'
    fno_skip='linear'
    channel_mlp_skip='linear'
    fno_skip='linear'
    channel_mlp_skip='linear'
    fno_skip='linear'
    channel_mlp_skip='linear'

    Our model has 1405761 parameters.




.. GENERATED FROM PYTHON SOURCE LINES 91-98

.. raw:: html

   <div style="margin-top: 3em;"></div>

Creating the optimizer and scheduler
------------------------------------
We use AdamW optimizer with weight decay for regularization

.. GENERATED FROM PYTHON SOURCE LINES 98-101

.. code-block:: Python

    optimizer = AdamW(model.parameters(), lr=8e-3, weight_decay=1e-4)
    scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=30)








.. GENERATED FROM PYTHON SOURCE LINES 102-109

.. raw:: html

   <div style="margin-top: 3em;"></div>

Setting up loss functions
-------------------------
We use H1 loss for training and L2 loss for evaluation

.. GENERATED FROM PYTHON SOURCE LINES 109-116

.. code-block:: Python

    l2loss = LpLoss(d=2, p=2)
    h1loss = H1Loss(d=2)

    train_loss = h1loss
    eval_losses = {"h1": h1loss, "l2": l2loss}









.. GENERATED FROM PYTHON SOURCE LINES 117-124

.. raw:: html

   <div style="margin-top: 3em;"></div>

Displaying configuration
------------------------
We print the model architecture, optimizer, scheduler, and loss functions

.. GENERATED FROM PYTHON SOURCE LINES 124-134

.. code-block:: Python


    print("\n### MODEL ###\n", model)
    print("\n### OPTIMIZER ###\n", optimizer)
    print("\n### SCHEDULER ###\n", scheduler)
    print("\n### LOSSES ###")
    print(f"\n * Train: {train_loss}")
    print(f"\n * Test: {eval_losses}")
    sys.stdout.flush()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ### MODEL ###
     UNO(
      (positional_embedding): GridEmbeddingND()
      (lifting): ChannelMLP(
        (fcs): ModuleList(
          (0): Conv1d(3, 256, kernel_size=(1,), stride=(1,))
          (1): Conv1d(256, 64, kernel_size=(1,), stride=(1,))
        )
      )
      (fno_blocks): ModuleList(
        (0): FNOBlocks(
          (convs): ModuleList(
            (0): SpectralConv(
              (weight): DenseTensor(shape=torch.Size([64, 32, 8, 5]), rank=None)
            )
          )
          (fno_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(64, 32, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
          (channel_mlp): ModuleList(
            (0): ChannelMLP(
              (fcs): ModuleList(
                (0): Conv1d(32, 16, kernel_size=(1,), stride=(1,))
                (1): Conv1d(16, 32, kernel_size=(1,), stride=(1,))
              )
            )
          )
          (channel_mlp_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(64, 32, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
        )
        (1): FNOBlocks(
          (convs): ModuleList(
            (0): SpectralConv(
              (weight): DenseTensor(shape=torch.Size([32, 64, 8, 5]), rank=None)
            )
          )
          (fno_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(32, 64, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
          (channel_mlp): ModuleList(
            (0): ChannelMLP(
              (fcs): ModuleList(
                (0): Conv1d(64, 32, kernel_size=(1,), stride=(1,))
                (1): Conv1d(32, 64, kernel_size=(1,), stride=(1,))
              )
            )
          )
          (channel_mlp_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(32, 64, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
        )
        (2): FNOBlocks(
          (convs): ModuleList(
            (0): SpectralConv(
              (weight): DenseTensor(shape=torch.Size([64, 64, 4, 3]), rank=None)
            )
          )
          (fno_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(64, 64, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
          (channel_mlp): ModuleList(
            (0): ChannelMLP(
              (fcs): ModuleList(
                (0): Conv1d(64, 32, kernel_size=(1,), stride=(1,))
                (1): Conv1d(32, 64, kernel_size=(1,), stride=(1,))
              )
            )
          )
          (channel_mlp_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(64, 64, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
        )
        (3): FNOBlocks(
          (convs): ModuleList(
            (0): SpectralConv(
              (weight): DenseTensor(shape=torch.Size([128, 64, 8, 5]), rank=None)
            )
          )
          (fno_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(128, 64, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
          (channel_mlp): ModuleList(
            (0): ChannelMLP(
              (fcs): ModuleList(
                (0): Conv1d(64, 32, kernel_size=(1,), stride=(1,))
                (1): Conv1d(32, 64, kernel_size=(1,), stride=(1,))
              )
            )
          )
          (channel_mlp_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(128, 64, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
        )
        (4): FNOBlocks(
          (convs): ModuleList(
            (0): SpectralConv(
              (weight): DenseTensor(shape=torch.Size([96, 32, 8, 5]), rank=None)
            )
          )
          (fno_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(96, 32, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
          (channel_mlp): ModuleList(
            (0): ChannelMLP(
              (fcs): ModuleList(
                (0): Conv1d(32, 16, kernel_size=(1,), stride=(1,))
                (1): Conv1d(16, 32, kernel_size=(1,), stride=(1,))
              )
            )
          )
          (channel_mlp_skips): ModuleList(
            (0): Flattened1dConv(
              (conv): Conv1d(96, 32, kernel_size=(1,), stride=(1,), bias=False)
            )
          )
        )
      )
      (horizontal_skips): ModuleDict(
        (0): Flattened1dConv(
          (conv): Conv1d(32, 32, kernel_size=(1,), stride=(1,), bias=False)
        )
        (1): Flattened1dConv(
          (conv): Conv1d(64, 64, kernel_size=(1,), stride=(1,), bias=False)
        )
      )
      (projection): ChannelMLP(
        (fcs): ModuleList(
          (0): Conv1d(32, 64, kernel_size=(1,), stride=(1,))
          (1): Conv1d(64, 1, kernel_size=(1,), stride=(1,))
        )
      )
    )

    ### OPTIMIZER ###
     AdamW (
    Parameter Group 0
        betas: (0.9, 0.999)
        correct_bias: True
        eps: 1e-06
        initial_lr: 0.008
        lr: 0.008
        weight_decay: 0.0001
    )

    ### SCHEDULER ###
     <torch.optim.lr_scheduler.CosineAnnealingLR object at 0x7f9e63b08ad0>

    ### LOSSES ###

     * Train: <neuralop.losses.data_losses.H1Loss object at 0x7f9e63b08d70>

     * Test: {'h1': <neuralop.losses.data_losses.H1Loss object at 0x7f9e63b08d70>, 'l2': <neuralop.losses.data_losses.LpLoss object at 0x7f9e63b08c20>}




.. GENERATED FROM PYTHON SOURCE LINES 135-142

.. raw:: html

   <div style="margin-top: 3em;"></div>

Creating the trainer
---------------------
We create a Trainer object that handles the training loop for the U-NO

.. GENERATED FROM PYTHON SOURCE LINES 142-153

.. code-block:: Python

    trainer = Trainer(
        model=model,
        n_epochs=30,
        device=device,
        data_processor=data_processor,
        wandb_log=False,  # Disable Weights & Biases logging
        eval_interval=5,  # Evaluate every 5 epochs
        use_distributed=False,  # Single GPU/CPU training
        verbose=True,
    )  # Print training progress








.. GENERATED FROM PYTHON SOURCE LINES 154-166

.. raw:: html

   <div style="margin-top: 3em;"></div>

Training the U-NO model
------------------------
We train the model on our Darcy-Flow dataset. The trainer will:

1. Run the forward pass through the U-NO
2. Compute the H1 loss
3. Backpropagate and update weights
4. Evaluate on test data every 5 epochs

.. GENERATED FROM PYTHON SOURCE LINES 166-179

.. code-block:: Python



    trainer.train(
        train_loader=train_loader,
        test_loaders=test_loaders,
        optimizer=optimizer,
        scheduler=scheduler,
        regularizer=False,
        training_loss=train_loss,
        eval_losses=eval_losses,
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Training on 1000 samples
    Testing on [50, 50] samples         on resolutions [16, 32].
    /opt/hostedtoolcache/Python/3.13.9/x64/lib/python3.13/site-packages/torch/utils/data/dataloader.py:668: UserWarning: 'pin_memory' argument is set as true but no accelerator is found, then device pinned memory won't be used.
      warnings.warn(warn_msg)
    /opt/hostedtoolcache/Python/3.13.9/x64/lib/python3.13/site-packages/torch/nn/modules/module.py:1786: UserWarning: UNO.forward() received unexpected keyword arguments: ['y']. These arguments will be ignored.
      return forward_call(*args, **kwargs)
    Raw outputs of shape torch.Size([32, 1, 16, 16])
    /home/runner/work/neuraloperator/neuraloperator/neuralop/training/trainer.py:536: UserWarning: H1Loss.__call__() received unexpected keyword arguments: ['x']. These arguments will be ignored.
      loss += training_loss(out, **sample)
    [0] time=4.81, avg_loss=0.6815, train_err=21.2965
    /home/runner/work/neuraloperator/neuraloperator/neuralop/training/trainer.py:581: UserWarning: LpLoss.__call__() received unexpected keyword arguments: ['x']. These arguments will be ignored.
      val_loss = loss(out, **sample)
    Eval: 16_h1=0.4432, 16_l2=0.3333, 32_h1=0.6444, 32_l2=0.3602
    [5] time=4.77, avg_loss=0.2197, train_err=6.8654
    Eval: 16_h1=0.3060, 16_l2=0.2268, 32_h1=0.4243, 32_l2=0.2449
    [10] time=4.81, avg_loss=0.1743, train_err=5.4477
    Eval: 16_h1=0.2215, 16_l2=0.1267, 32_h1=0.4078, 32_l2=0.1656
    [15] time=4.88, avg_loss=0.1883, train_err=5.8848
    Eval: 16_h1=0.2363, 16_l2=0.1478, 32_h1=0.4090, 32_l2=0.1827
    [20] time=4.80, avg_loss=0.1180, train_err=3.6878
    Eval: 16_h1=0.2192, 16_l2=0.1219, 32_h1=0.3685, 32_l2=0.1310
    [25] time=4.76, avg_loss=0.0984, train_err=3.0764
    Eval: 16_h1=0.1984, 16_l2=0.1088, 32_h1=0.3971, 32_l2=0.1464

    {'train_err': 2.4950771890580654, 'avg_loss': 0.07984247004985809, 'avg_lasso_loss': None, 'epoch_train_time': 4.764496043999998}



.. GENERATED FROM PYTHON SOURCE LINES 180-195

.. raw:: html

   <div style="margin-top: 3em;"></div>

Visualizing U-NO predictions
-----------------------------
We visualize the model's predictions on the Darcy-Flow dataset.
Note that we trained on a very small resolution for a very small number of epochs.
In practice, we would train at larger resolution on many more samples.

However, for practicality, we created a minimal example that:
i) fits in just a few MB of memory
ii) can be trained quickly on CPU

In practice we would train a Neural Operator on one or multiple GPUs

.. GENERATED FROM PYTHON SOURCE LINES 195-236

.. code-block:: Python


    test_samples = test_loaders[32].dataset

    fig = plt.figure(figsize=(7, 7))
    for index in range(3):
        data = test_samples[index]
        data = data_processor.preprocess(data, batched=False)
        # Input x
        x = data["x"]
        # Ground-truth
        y = data["y"]
        # Model prediction: U-NO output
        out = model(x.unsqueeze(0).to(device)).cpu()

        # Plot input x
        ax = fig.add_subplot(3, 3, index * 3 + 1)
        ax.imshow(x[0], cmap="gray")
        if index == 0:
            ax.set_title("Input x")
        plt.xticks([], [])
        plt.yticks([], [])

        # Plot ground-truth y
        ax = fig.add_subplot(3, 3, index * 3 + 2)
        ax.imshow(y.squeeze())
        if index == 0:
            ax.set_title("Ground-truth y")
        plt.xticks([], [])
        plt.yticks([], [])

        # Plot model prediction
        ax = fig.add_subplot(3, 3, index * 3 + 3)
        ax.imshow(out.squeeze().detach().numpy())
        if index == 0:
            ax.set_title("U-NO prediction")
        plt.xticks([], [])
        plt.yticks([], [])

    fig.suptitle("U-NO predictions on 32x32 Darcy-Flow data", y=0.98)
    plt.tight_layout()
    fig.show()



.. image-sg:: /auto_examples/models/images/sphx_glr_plot_UNO_darcy_001.png
   :alt: U-NO predictions on 32x32 Darcy-Flow data, Input x, Ground-truth y, U-NO prediction
   :srcset: /auto_examples/models/images/sphx_glr_plot_UNO_darcy_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (2 minutes 29.547 seconds)


.. _sphx_glr_download_auto_examples_models_plot_UNO_darcy.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_UNO_darcy.ipynb <plot_UNO_darcy.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_UNO_darcy.py <plot_UNO_darcy.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_UNO_darcy.zip <plot_UNO_darcy.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
