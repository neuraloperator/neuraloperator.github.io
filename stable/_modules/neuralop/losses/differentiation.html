<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>neuralop.losses.differentiation &#8212; neuraloperator 2.0.0 documentation</title> 
<link rel="stylesheet" href="../../../_static/tensorly_style.css">
<link rel="apple-touch-icon" sizes="180x180" href="../../../_static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../../_static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../../_static/favicon/favicon-16x16.png">
<link rel="manifest" href="../../../_static/favicon/site.webmanifest">
<link rel="mask-icon" href="../../../_static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="../../../_static/favicon/favicon.ico">
<meta name="theme-color" content="#ffffff">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/tensorly_style.css?v=a02e9698" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=5126dfd5" />

  
    <script src="../../../_static/documentation_options.js?v=51b770b3"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
 <script src="../../../_static/navbar_burger.js"></script>
 <script defer src="https://use.fontawesome.com/releases/v5.14.0/js/all.js"></script>
 
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  </head>
<body  class="has-navbar-fixed-top">

  <header>
    <navbar>
      <nav class="navbar top-navbar is-fixed-top has-shadow is-flex-wrap-wrap" role="navigation" aria-label="main top navigation">
        <div class="navbar-brand">
        

          <a class="navbar-item" href="../../../index.html">
            <img src="../../../_static/neuraloperator_logo.png" height="28">
          </a>
          <a class="navbar-item is-hidden-desktop" href="https://github.com/neuraloperator/neuraloperator" target="_blank">
              <span class="icon"><i class="fab fa-github"></i></span>
          </a>

          <a role="button" class="navbar-burger" data-target="top-nav-menu" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
          </a>

        </div>
        
        <div class="navbar-menu" id="top-nav-menu">
        

          <div class="navbar-start">
            
              <a class="navbar-item" href="../../../install.html">
              Install
            </a>
              <a class="navbar-item" href="../../../theory_guide/index.html">
              Theory Guide
            </a>
              <a class="navbar-item" href="../../../user_guide/index.html">
              User Guide
            </a>
              <a class="navbar-item" href="../../../modules/api.html">
              API
            </a>
              <a class="navbar-item" href="../../../auto_examples/index.html">
              Examples
            </a>
              <a class="navbar-item" href="../../../dev_guide/index.html">
              Developer's Guide
            </a>
          </div>
        
          <div class="navbar-end">
            <div class="navbar-item">
            
            <a class="button is-hidden-touch is-dark" href="https://github.com/neuraloperator/neuraloperator" target="_blank">
              <span class="icon-text">
                <span class="icon is-large">
                  <i class="fab fa-github"></i>
                </span>
                <span>Github</span>
              </span>
            </a>

            </div> 
          </div> 
        </div> 

      </nav>
      
    </navbar>
  </header>


  <div id="column-container">
  <div class="columns is-mobile is-centered">
	
  

  <div class="column main-column">

    
    <div class="main-section">

      
      

      <div class="container content main-content">
        
  <h1>Source code for neuralop.losses.differentiation</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..layers.fourier_continuation</span><span class="w"> </span><span class="kn">import</span> <span class="n">FCLegendre</span><span class="p">,</span> <span class="n">FCGram</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">differentiation.py implements utilities for computing derivatives via finite-differences</span>
<span class="sd">and Fourier/spectral differentiation methods</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="FiniteDiff">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FiniteDiff</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A unified class for computing finite differences in 1D, 2D, or 3D.</span>

<span class="sd">    This class provides comprehensive methods for computing derivatives using finite differences</span>
<span class="sd">    with support for both periodic and non-periodic boundary conditions.</span>

<span class="sd">    It implements the following high-order finite difference schemes:</span>
<span class="sd">    - Interior points: Second-order central differences for optimal accuracy</span>
<span class="sd">    - Periodic boundaries: Uses torch.roll for seamless periodic wrapping.</span>
<span class="sd">    - Non-periodic boundaries: Uses third-order one-sided differences at boundary points.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : int</span>
<span class="sd">        Dimension of the input field. Must be 1, 2, or 3.</span>
<span class="sd">    h : float or tuple, optional</span>
<span class="sd">        Grid spacing(s) for finite difference calculations, by default 1.0.</span>
<span class="sd">        - For 1D: single float or tuple with one element</span>
<span class="sd">        - For 2D: tuple (h_x, h_y) or single float for uniform spacing</span>
<span class="sd">        - For 3D: tuple (h_x, h_y, h_z) or single float for uniform spacing</span>
<span class="sd">    periodic_in_x : bool, optional</span>
<span class="sd">        Whether to use periodic boundary conditions in x-direction, by default True.</span>
<span class="sd">        When True, uses torch.roll for efficient periodic wrapping.</span>
<span class="sd">        When False, uses high-order one-sided differences at boundaries.</span>
<span class="sd">    periodic_in_y : bool, optional</span>
<span class="sd">        Whether to use periodic boundary conditions in y-direction, by default True.</span>
<span class="sd">        When True, uses torch.roll for efficient periodic wrapping.</span>
<span class="sd">        When False, uses high-order one-sided differences at boundaries.</span>
<span class="sd">        Only used for 2D and 3D fields.</span>
<span class="sd">    periodic_in_z : bool, optional</span>
<span class="sd">        Whether to use periodic boundary conditions in z-direction, by default True.</span>
<span class="sd">        When True, uses torch.roll for efficient periodic wrapping.</span>
<span class="sd">        When False, uses high-order one-sided differences at boundaries.</span>
<span class="sd">        Only used for 3D fields.</span>


<span class="sd">    Available Methods</span>
<span class="sd">    ----------------</span>
<span class="sd">    Derivative Methods:</span>
<span class="sd">    - dx(u, order=1): Compute derivative with respect to x</span>
<span class="sd">    - dy(u, order=1): Compute derivative with respect to y (2D/3D only)</span>
<span class="sd">    - dz(u, order=1): Compute derivative with respect to z (3D only)</span>

<span class="sd">    Vector Calculus Operators:</span>
<span class="sd">    - laplacian(u): Compute the Laplacian ∇²f</span>
<span class="sd">    - gradient(u): Compute the gradient ∇f (returns vector field)</span>
<span class="sd">    - divergence(u): Compute the divergence ∇·u (for vector fields)</span>
<span class="sd">    - curl(u): Compute the curl ∇×u (for vector fields, 2D/3D only)</span>


<span class="sd">    Mathematical Formulas</span>
<span class="sd">    ---------------------</span>
<span class="sd">    For first-order derivatives:</span>
<span class="sd">    - Interior: (f_{i+1} - f_{i-1})/(2h)  [2nd order central]</span>
<span class="sd">    - Left boundary: (-11f_0 + 18f_1 - 9f_2 + 2f_3)/(6h)  [3rd order forward]</span>
<span class="sd">    - Right boundary: (-2f_{n-4} + 9f_{n-3} - 18f_{n-2} + 11f_{n-1})/(6h)  [3rd order backward]</span>

<span class="sd">    For second-order derivatives:</span>
<span class="sd">    - Interior: (f_{i+1} - 2f_i + f_{i-1})/(h²)  [2nd order central]</span>
<span class="sd">    - Left boundary: (2f_0 - 5f_1 + 4f_2 - f_3)/(h²)  [3rd order forward]</span>
<span class="sd">    - Right boundary: (-f_{n-4} + 4f_{n-3} - 5f_{n-2} + 2f_{n-1})/(h²)  [3rd order backward]</span>
<span class="sd">    </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # 1D finite differences</span>
<span class="sd">    &gt;&gt;&gt; x = torch.linspace(0, 2*torch.pi, 100)</span>
<span class="sd">    &gt;&gt;&gt; u = torch.sin(x)</span>
<span class="sd">    &gt;&gt;&gt; fd1d = FiniteDiff(dim=1, h=0.1, periodic_in_x=True)</span>
<span class="sd">    &gt;&gt;&gt; du_dx = fd1d.dx(u)  # First derivative</span>
<span class="sd">    &gt;&gt;&gt; d2u_dx2 = fd1d.dx(u, order=2)  # Second derivative</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # 2D finite differences</span>
<span class="sd">    &gt;&gt;&gt; fd2d = FiniteDiff(dim=2, h=(0.1, 0.1), periodic_in_x=True, periodic_in_y=False)</span>
<span class="sd">    &gt;&gt;&gt; x = torch.linspace(0, 2*torch.pi, 50)</span>
<span class="sd">    &gt;&gt;&gt; y = torch.linspace(0, 2*torch.pi, 50)</span>
<span class="sd">    &gt;&gt;&gt; X, Y = torch.meshgrid(x, y, indexing=&#39;ij&#39;)</span>
<span class="sd">    &gt;&gt;&gt; u = torch.sin(X) * torch.cos(Y)</span>
<span class="sd">    &gt;&gt;&gt; du_dx = fd2d.dx(u)</span>
<span class="sd">    &gt;&gt;&gt; du_dy = fd2d.dy(u)</span>
<span class="sd">    &gt;&gt;&gt; grad = fd2d.gradient(u)  # Returns [du_dx, du_dy]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # 3D finite differences</span>
<span class="sd">    &gt;&gt;&gt; fd3d = FiniteDiff(dim=3, h=(0.1, 0.1, 0.1), periodic_in_x=True, periodic_in_y=True, periodic_in_z=False)</span>
<span class="sd">    &gt;&gt;&gt; x = torch.linspace(0, 2*torch.pi, 20)</span>
<span class="sd">    &gt;&gt;&gt; y = torch.linspace(0, 2*torch.pi, 20)</span>
<span class="sd">    &gt;&gt;&gt; z = torch.linspace(0, 2*torch.pi, 20)</span>
<span class="sd">    &gt;&gt;&gt; X, Y, Z = torch.meshgrid(x, y, z, indexing=&#39;ij&#39;)</span>
<span class="sd">    &gt;&gt;&gt; u = torch.sin(X) * torch.cos(Y) * torch.sin(Z)  # 3D scalar field</span>
<span class="sd">    &gt;&gt;&gt; du_dx = fd3d.dx(u)</span>
<span class="sd">    &gt;&gt;&gt; du_dy = fd3d.dy(u)</span>
<span class="sd">    &gt;&gt;&gt; du_dz = fd3d.dz(u)</span>
<span class="sd">    &gt;&gt;&gt; laplacian = fd3d.laplacian(u)  # Sum of all second derivatives</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Vector field operations</span>
<span class="sd">    &gt;&gt;&gt; vx = torch.sin(X) * torch.cos(Y) * torch.sin(Z)</span>
<span class="sd">    &gt;&gt;&gt; vy = torch.cos(X) * torch.sin(Y) * torch.cos(Z)</span>
<span class="sd">    &gt;&gt;&gt; vz = torch.sin(X) * torch.sin(Y) * torch.cos(Z)</span>
<span class="sd">    &gt;&gt;&gt; v = torch.stack([vx, vy, vz], dim=-4)  # 3D vector field</span>
<span class="sd">    &gt;&gt;&gt; div_v = fd3d.divergence(v)  # Scalar field</span>
<span class="sd">    &gt;&gt;&gt; curl_v = fd3d.curl(v)  # Vector field</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">periodic_in_x</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">periodic_in_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">periodic_in_z</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the FiniteDiff class for computing finite differences.</span>

<span class="sd">        See class docstring for detailed parameter descriptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if dim is valid</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dim must be 1, 2, or 3&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="c1"># Set up grid spacing</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="c1"># Create tuple of length dim with repeated h value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">h</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># h is already a tuple/list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">D, h must be a float or a tuple of length </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>  <span class="c1"># Convert to tuple</span>

        <span class="c1"># Set up periodic conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_x</span> <span class="o">=</span> <span class="n">periodic_in_x</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_y</span> <span class="o">=</span> <span class="n">periodic_in_y</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_z</span> <span class="o">=</span> <span class="n">periodic_in_z</span>

<div class="viewcode-block" id="FiniteDiff.dx">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff.dx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute derivative with respect to x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input tensor</span>
<span class="sd">        order : int, optional</span>
<span class="sd">            Order of the derivative, by default 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Derivative with respect to x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># dim == 3</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="FiniteDiff.dy">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff.dy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute derivative with respect to y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input tensor</span>
<span class="sd">        order : int, optional</span>
<span class="sd">            Order of the derivative, by default 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Derivative with respect to y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dy is only available for 2D and 3D&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># dim == 3</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="FiniteDiff.dz">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff.dz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute derivative with respect to z.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input tensor</span>
<span class="sd">        order : int, optional</span>
<span class="sd">            Order of the derivative, by default 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            Derivative with respect to z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dz is only available for 3D&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="FiniteDiff.laplacian">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff.laplacian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">laplacian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Laplacian ∇²f.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input tensor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The Laplacian of the input tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># dim == 3</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="FiniteDiff.gradient">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff.gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the gradient ∇f for scalar fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input scalar field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The gradient of the scalar field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">grad_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grad_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">grad_x</span><span class="p">,</span> <span class="n">grad_y</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># dim == 3</span>
            <span class="n">grad_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grad_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grad_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">grad_x</span><span class="p">,</span> <span class="n">grad_y</span><span class="p">,</span> <span class="n">grad_z</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">4</span><span class="p">)</span></div>


<div class="viewcode-block" id="FiniteDiff.divergence">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff.divergence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">divergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the divergence ∇·u for vector fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input vector field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The divergence of the vector field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check input dimensions match vector field components</span>
        <span class="n">n_components_expected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">n_components_actual</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_components_actual</span> <span class="o">!=</span> <span class="n">n_components_expected</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input must be a </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">D vector field with </span><span class="si">{</span><span class="n">n_components_expected</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1d</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2d</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2d</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># dim == 3</span>
            <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">u3</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_3d</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_3d</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_3d</span><span class="p">(</span><span class="n">u3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="FiniteDiff.curl">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FiniteDiff.html#neuralop.losses.differentiation.FiniteDiff.curl">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">curl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the curl ∇×u for vector fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input vector field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The curl of the vector field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Curl is not defined for 1D&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must be a 2D vector field with 2 components&quot;</span><span class="p">)</span>
            <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2d</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2d</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># dim == 3</span>
            <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must be a 3D vector field with 3 components&quot;</span><span class="p">)</span>
            <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">u3</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">curl_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_3d</span><span class="p">(</span><span class="n">u3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_3d</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">curl_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_3d</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_3d</span><span class="p">(</span><span class="n">u3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">curl_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_3d</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_3d</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">curl_x</span><span class="p">,</span> <span class="n">curl_y</span><span class="p">,</span> <span class="n">curl_z</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">4</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;1D derivative with respect to x.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1st_1d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2nd_1d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only 1st and 2nd order derivatives currently supported&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_1st_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First order derivative with respect to x (1D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_x</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i+1} - f_{i-1})/(2h)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences  (f_{i+1} - f_{i-1})/(2h)</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Left boundary: 3rd-order forward differences (-11f_{0} + 18f_{1} - 9f_{2} + 2f_{3})/(6h)</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="c1"># Right boundary: 3rd-order backward differences (-2f_{n-4} + 9f_{n-3} - 18f_{n-2} + 11f_{n-1})/(6h)</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">dx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_2nd_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second order derivative with respect to x (1D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_x</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i+1} - 2f_{i} + f_{i-1})/(h²)</span>
            <span class="n">dxx</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dxx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i+1} - 2f_{i} + f_{i-1})/(h²)</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Left boundary: 3rd-order forward differences (2f_{0} - 5f_{1} + 4f_{2} - f_{3})/h²</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Right boundary: 3rd-order backward differences (-f_{n-4} + 4f_{n-3} - 5f_{n-2} + 2f_{n-1})/h²</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dxx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2D derivative with respect to x.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1st_2d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2nd_2d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only 1st and 2nd order derivatives currently supported&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2D derivative with respect to y.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_1st_2d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2nd_2d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only 1st and 2nd order derivatives currently supported&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_1st_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First order derivative with respect to x (2D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_x</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i+1,j} - f_{i-1,j})/(2h_{x})</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i+1,j} - f_{i-1,j})/(2h_{x})</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Left boundary: 3rd-order forward differences (-11f_{0} + 18f_{1} - 9f_{2} + 2f_{3})/(6h_{x})</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="c1"># Right boundary: 3rd-order backward differences (-2f_{n-4} + 9f_{n-3} - 18f_{n-2} + 11f_{n-1})/(6h_{x})</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">dx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_1st_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First order derivative with respect to y (2D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_y</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i,j+1} - f_{i,j-1})/(2h_{y})</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i,j+1} - f_{i,j-1})/(2h_{y})</span>
            <span class="n">dy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Bottom boundary: 3rd-order forward differences (-11f_{0} + 18f_{1} - 9f_{2} + 2f_{3})/(6h_{y})</span>
            <span class="n">dy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Top boundary: 3rd-order backward differences (-2f_{n-4} + 9f_{n-3} - 18f_{n-2} + 11f_{n-1})/(6h_{y})</span>
            <span class="n">dy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">dy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_2nd_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second order derivative with respect to x (2D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_x</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i+1,j} - 2f_{i,j} + f_{i-1,j})/(h_{x}²)</span>
            <span class="n">dxx</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dxx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i+1,j} - 2f_{i,j} + f_{i-1,j})/(h_{x}²)</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Left boundary: 3rd-order forward differences (2f_{0} - 5f_{1} + 4f_{2} - f_{3})/h_{x}²</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Right boundary: 3rd-order backward differences (-f_{n-4} + 4f_{n-3} - 5f_{n-2} + 2f_{n-1})/h_{x}²</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dxx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_2nd_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second order derivative with respect to y (2D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_y</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i,j+1} - 2f_{i,j} + f_{i,j-1})/(h_{y}²)</span>
            <span class="n">dyy</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dyy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i,j+1} - 2f_{i,j} + f_{i,j-1})/(h_{y}²)</span>
            <span class="n">dyy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Bottom boundary: 3rd-order forward differences (2f_{0} - 5f_{1} + 4f_{2} - f_{3})/h_{y}²</span>
            <span class="n">dyy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Top boundary: 3rd-order backward differences (-f_{n-4} + 4f_{n-3} - 5f_{n-2} + 2f_{n-1})/h_{y}²</span>
            <span class="n">dyy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dyy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D derivative with respect to x.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1st_3d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2nd_3d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only 1st and 2nd order derivatives currently supported&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D derivative with respect to y.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_1st_3d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2nd_3d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only 1st and 2nd order derivatives currently supported&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dz_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D derivative with respect to z.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_1st_3d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_2nd_3d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only 1st and 2nd order derivatives currently supported&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_1st_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First order derivative with respect to x (3D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_x</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i+1,j,k} - f_{i-1,j,k})/(2h_{x})</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">3</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i+1,j,k} - f_{i-1,j,k})/(2h_{x})</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Left boundary: 3rd-order forward differences (-11f_{0} + 18f_{1} - 9f_{2} + 2f_{3})/(6h_{x})</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Right boundary: 3rd-order backward differences (-2f_{n-4} + 9f_{n-3} - 18f_{n-2} + 11f_{n-1})/(6h_{x})</span>
            <span class="n">dx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">dx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_1st_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First order derivative with respect to y (3D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_y</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i,j+1,k} - f_{i,j-1,k})/(2h_{y})</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i,j+1,k} - f_{i,j-1,k})/(2h_{y})</span>
            <span class="n">dy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Bottom boundary: 3rd-order forward differences (-11f_{0} + 18f_{1} - 9f_{2} + 2f_{3})/(6h_{y})</span>
            <span class="n">dy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Top boundary: 3rd-order backward differences (-2f_{n-4} + 9f_{n-3} - 18f_{n-2} + 11f_{n-1})/(6h_{y})</span>
            <span class="n">dy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">dy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dz_1st_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First order derivative with respect to z (3D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_z</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i,j,k+1} - f_{i,j,k-1})/(2h_{z})</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i,j,k+1} - f_{i,j,k-1})/(2h_{z})</span>
            <span class="n">dz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># Front boundary: 3rd-order forward differences (-11f_{0} + 18f_{1} - 9f_{2} + 2f_{3})/(6h_{z})</span>
            <span class="n">dz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># Back boundary: 3rd-order backward differences (-2f_{n-4} + 9f_{n-3} - 18f_{n-2} + 11f_{n-1})/(6h_{z})</span>
            <span class="n">dz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">18</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">11</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">dz</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_2nd_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second order derivative with respect to x (3D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_x</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k})/(h_{x}²)</span>
            <span class="n">dxx</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">3</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dxx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i+1,j,k} - 2f_{i,j,k} + f_{i-1,j,k})/(h_{x}²)</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Left boundary: 3rd-order forward differences (2f_{0} - 5f_{1} + 4f_{2} - f_{3})/h_{x}²</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Right boundary: 3rd-order backward differences (-f_{n-4} + 4f_{n-3} - 5f_{n-2} + 2f_{n-1})/h_{x}²</span>
            <span class="n">dxx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dxx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_2nd_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second order derivative with respect to y (3D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_y</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i,j+1,k} - 2f_{i,j,k} + f_{i,j-1,k})/(h_{y}²)</span>
            <span class="n">dyy</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dyy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i,j+1,k} - 2f_{i,j,k} + f_{i,j-1,k})/(h_{y}²)</span>
            <span class="n">dyy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Bottom boundary: 3rd-order forward differences (2f_{0} - 5f_{1} + 4f_{2} - f_{3})/h_{y}²</span>
            <span class="n">dyy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Top boundary: 3rd-order backward differences (-f_{n-4} + 4f_{n-3} - 5f_{n-2} + 2f_{n-1})/h_{y}²</span>
            <span class="n">dyy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dyy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dz_2nd_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second order derivative with respect to z (3D).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic_in_z</span><span class="p">:</span>
            <span class="c1"># Periodic case: use torch.roll for boundary wrapping</span>
            <span class="c1"># Central difference: (f_{i,j,k+1} - 2f_{i,j,k} + f_{i,j,k-1})/(h_{z}²)</span>
            <span class="n">dzz</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span>
                   <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-periodic case: handle boundaries separately</span>
            <span class="n">dzz</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

            <span class="c1"># Interior points: Second-order central differences</span>
            <span class="c1"># (f_{i,j,k+1} - 2f_{i,j,k} + f_{i,j,k-1})/(h_{z}²)</span>
            <span class="n">dzz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Front boundary: 3rd-order forward differences (2f_{0} - 5f_{1} + 4f_{2} - f_{3})/h_{z}²</span>
            <span class="n">dzz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Back boundary: 3rd-order backward differences (-f_{n-4} + 4f_{n-3} - 5f_{n-2} + 2f_{n-1})/h_{z}²</span>
            <span class="n">dzz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">dzz</span></div>



<span class="c1"># Backward compatibility functions</span>
<span class="k">def</span><span class="w"> </span><span class="nf">central_diff_1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">periodic_in_x</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Backward compatibility function for central_diff_1d.</span>
<span class="sd">    Creates a FiniteDiff instance with dim=1 and returns dx.</span>

<span class="sd">    .. deprecated::</span>
<span class="sd">        This function is deprecated and will be removed in future versions.</span>
<span class="sd">        Please use the FiniteDiff class instead for better performance and features.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;central_diff_1d is deprecated and may not be maintained. &quot;</span>
        <span class="s2">&quot;Please use FiniteDiff class instead for better performance and features.&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fd1d</span> <span class="o">=</span> <span class="n">FiniteDiff</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">periodic_in_x</span><span class="o">=</span><span class="n">periodic_in_x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fd1d</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">central_diff_2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">periodic_in_x</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">periodic_in_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Backward compatibility function for central_diff_2d.</span>
<span class="sd">    Creates a FiniteDiff instance with dim=2 and returns dx, dy.</span>

<span class="sd">    .. deprecated::</span>
<span class="sd">        This function is deprecated and will be removed in future versions.</span>
<span class="sd">        Please use the FiniteDiff class instead for better performance and features.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;central_diff_2d is deprecated and may not be maintained. &quot;</span>
        <span class="s2">&quot;Please use FiniteDiff class instead for better performance and features.&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fd2d</span> <span class="o">=</span> <span class="n">FiniteDiff</span><span class="p">(</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">periodic_in_x</span><span class="o">=</span><span class="n">periodic_in_x</span><span class="p">,</span> <span class="n">periodic_in_y</span><span class="o">=</span><span class="n">periodic_in_y</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">fd2d</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fd2d</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">central_diff_3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">periodic_in_x</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">periodic_in_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">periodic_in_z</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Backward compatibility function for central_diff_3d.</span>
<span class="sd">    Creates a FiniteDiff instance with dim=3 and returns dx, dy, dz.</span>

<span class="sd">    .. deprecated::</span>
<span class="sd">        This function is deprecated and will be removed in future versions.</span>
<span class="sd">        Please use the FiniteDiff class instead for better performance and features.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;central_diff_3d is deprecated and may not be maintained. &quot;</span>
        <span class="s2">&quot;Please use FiniteDiff class instead for better performance and features.&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fd3d</span> <span class="o">=</span> <span class="n">FiniteDiff</span><span class="p">(</span>
        <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
        <span class="n">periodic_in_x</span><span class="o">=</span><span class="n">periodic_in_x</span><span class="p">,</span>
        <span class="n">periodic_in_y</span><span class="o">=</span><span class="n">periodic_in_y</span><span class="p">,</span>
        <span class="n">periodic_in_z</span><span class="o">=</span><span class="n">periodic_in_z</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">fd3d</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fd3d</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fd3d</span><span class="o">.</span><span class="n">dz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_non_uniform_fd_weights</span><span class="p">(</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">derivative_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regularize_lstsq</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute finite difference weights for approximating the first order derivative</span>
<span class="sd">    on an unstructured grid of points</span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    points : torch tensor of shape (N, d) containing the d coordinates of the N points</span>
<span class="sd">    num_neighbors: int for the number of nearest neighbors to include in the stencil (including the point itself)</span>
<span class="sd">                    At least 3 and at most N</span>
<span class="sd">    derivative_indices : indices of the derivatives to compute, e.g. in 2D, [0] for x, [1] for y, [0, 1] for x and y</span>
<span class="sd">    radius : float, the cutoff distance to use a neighbor as radius</span>
<span class="sd">             Neighbors with distances beyond this value are not used (their weights are set to zero)</span>
<span class="sd">             Always keep at least 3 neighbors (including the point itself)</span>
<span class="sd">    regularize_lstsq : bool, whether to regularize the least squares system</span>
<span class="sd">                        Sometimes torch.linalg.lstsq(A, b).solution creates artifacts so can add regularizer</span>
<span class="sd">                        But regularizer can deteriorate performance when system is well-conditioned</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    indices : torch tensor of shape (N, k) for the indices of k nearest neighbors (including the point itself)</span>
<span class="sd">    fd_weights : torch tensor of weights of shape (N, len(derivative_indices), k)</span>
<span class="sd">                fd_weights[i,j,m] contains the weights for the m-th nearest neighbor</span>
<span class="sd">                                        in the j-th 1st order derivative for the i-th point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">N</span><span class="p">)</span>

    <span class="c1"># Get the indices of the k nearest neighbors (including the point itself)</span>
    <span class="n">pairwise_distances</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="n">pairwise_distances</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">largest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Get mask for neighbors within cutoff radius (and always keep at least 3)</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">radius_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">radius_mask</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">&lt;=</span> <span class="n">radius</span>
        <span class="n">radius_mask</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Initialize A to 1 since first row for each point and derivative is 1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="c1"># Compute coordinate differences</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Repeat it for each derivative to be evaluated so it becomes of shape (N,</span>
    <span class="c1"># len(derivative_indices), d+1, k)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">derivative_indices</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Zero out columns for neighbors that are not within the radius</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">radius_mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Compute right hand side</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">derivative_indices</span><span class="p">),</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">device</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">derivative_indices</span><span class="p">)):</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">derivative_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Repeat so it becomes (N, len(derivative_indices), d+1, 1)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Solve least squares system Aw = b</span>
    <span class="c1">#    sometimes torch.linalg.lstsq(A, b).solution creates artifacts so can add regularizer</span>
    <span class="c1"># but regularizer can deteriorate performance when system is</span>
    <span class="c1"># well-conditioned</span>

    <span class="k">if</span> <span class="n">regularize_lstsq</span><span class="p">:</span>
        <span class="n">lambda_reg</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="n">I_k</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">AT</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">AT_b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">AT_A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">lambda_reg</span> <span class="o">*</span> <span class="n">I_k</span>

        <span class="c1"># Use Cholesky decomposition to accelerate torch.linalg.solve(AT_A,</span>
        <span class="c1"># AT_b).squeeze(-1)</span>
        <span class="n">fd_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">AT_b</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">AT_A</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">fd_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">solution</span>

    <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">fd_weights</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="non_uniform_fd">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.non_uniform_fd.html#neuralop.losses.differentiation.non_uniform_fd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">non_uniform_fd</span><span class="p">(</span>
    <span class="n">points</span><span class="p">,</span>
    <span class="n">values</span><span class="p">,</span>
    <span class="n">num_neighbors</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">derivative_indices</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">regularize_lstsq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finite difference approximation of first order derivatives on unstructured point clouds.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    points : torch tensor of shape (N, d) containing the d coordinates of the N points</span>
<span class="sd">    values : torch tensor of shape (N) containing the values of the function at the N points</span>
<span class="sd">    radius : float, the cutoff distance to use a neighbor as radius</span>
<span class="sd">             Neighbors with distances beyond this value are not used (their weights are set to zero)</span>
<span class="sd">             Always keep at least 3 neighbors (including the point itself)</span>
<span class="sd">    num_neighbors: int for the number of nearest neighbors to include in the stencil (including the point itself)</span>
<span class="sd">    derivative_indices : indices of the derivatives to compute, e.g. in 2D, [0] for x, [1] for y, [0, 1] for x and y</span>
<span class="sd">    regularize_lstsq : bool, whether to regularize the least squares system</span>
<span class="sd">                        Sometimes torch.linalg.lstsq(A, b).solution creates artifacts so can add regularizer</span>
<span class="sd">                        But regularizer can deteriorate performance when system is well-conditioned</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    derivatives: tensor of shape (len(derivative_indices), N) of derivatives</span>
<span class="sd">            e.g. in 2D with derivative_indices=[0, 1], derivatives[0] is df(x,y)/dx and derivatives[1] is df(x,y)/dy</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">indices</span><span class="p">,</span> <span class="n">fd_weights</span> <span class="o">=</span> <span class="n">get_non_uniform_fd_weights</span><span class="p">(</span>
        <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
        <span class="n">num_neighbors</span><span class="o">=</span><span class="n">num_neighbors</span><span class="p">,</span>
        <span class="n">derivative_indices</span><span class="o">=</span><span class="n">derivative_indices</span><span class="p">,</span>
        <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
        <span class="n">regularize_lstsq</span><span class="o">=</span><span class="n">regularize_lstsq</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">derivatives</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;nij,nj-&gt;in&quot;</span><span class="p">,</span> <span class="n">fd_weights</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">derivatives</span></div>



<div class="viewcode-block" id="FourierDiff">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FourierDiff</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A unified class for computing Fourier/spectral derivatives in 1D, 2D, 3D.</span>

<span class="sd">    This class provides comprehensive methods for computing derivatives using Fourier/spectral</span>
<span class="sd">    methods with support for both periodic and non-periodic functions through Fourier continuation:</span>
<span class="sd">    - Periodic functions: Direct Fourier differentiation using FFT</span>
<span class="sd">    - Non-periodic functions: Fourier continuation (FC) is used to extend functions to larger domain </span>
<span class="sd">            on which the functions are periodic before applying Fourier differentiation with FFT.</span>

<span class="sd">    The class also provides gradient, divergence, curl, and Laplacian operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : int</span>
<span class="sd">        Dimension of the input field. Must be 1, 2, or 3.</span>
<span class="sd">    L : float or tuple, optional</span>
<span class="sd">        Length of the domain for Fourier differentiation. By default 2*pi for each dimension.</span>
<span class="sd">    use_fc : str, optional</span>
<span class="sd">        Whether to use Fourier continuation for non-periodic functions.</span>
<span class="sd">        Options: False (no FC), &#39;Legendre&#39;, &#39;Gram&#39;. By default False.</span>
<span class="sd">    fc_degree : int, optional</span>
<span class="sd">        Degree of the Fourier continuation polynomial matching. This is the number</span>
<span class="sd">        of matching points on the left and right boundaries used for the Fourier</span>
<span class="sd">        continuation procedure. By default 4.</span>
<span class="sd">    fc_n_additional_pts : int, optional</span>
<span class="sd">        Number of additional points to add with the Fourier continuation layer.</span>
<span class="sd">        This extends the domain to handle non-periodic functions. By default 50.</span>
<span class="sd">    low_pass_filter_ratio : float, optional</span>
<span class="sd">        If not None, apply a low-pass filter to the Fourier coefficients to reduce</span>
<span class="sd">        high-frequency noise. Should be between 0 and 1. By default None.</span>


<span class="sd">    Available Methods</span>
<span class="sd">    ----------------</span>
<span class="sd">    Derivative Methods:</span>
<span class="sd">    - dx(u, order=1): Compute derivative with respect to x</span>
<span class="sd">    - dy(u, order=1): Compute derivative with respect to y (2D/3D only)</span>
<span class="sd">    - dz(u, order=1): Compute derivative with respect to z (3D only)</span>
<span class="sd">    - derivative(u, order): Compute derivative with order tuple (e.g., (1,0) for ∂/∂x)</span>

<span class="sd">    Vector Calculus Operators:</span>
<span class="sd">    - laplacian(u): Compute the Laplacian ∇²f</span>
<span class="sd">    - gradient(u): Compute the gradient ∇f (returns vector field)</span>
<span class="sd">    - divergence(u): Compute the divergence ∇·u (for vector fields)</span>
<span class="sd">    - curl(u): Compute the curl ∇×u (for vector fields, 2D/3D only)</span>


<span class="sd">    Mathematical Background</span>
<span class="sd">    -----------------------</span>
<span class="sd">    For periodic functions on [0, 2π], the derivative is computed as:</span>
<span class="sd">    - Forward transform: û_k = FFT(u)</span>
<span class="sd">    - Derivative in Fourier space: (∂u/∂x)^_k = ik * û_k</span>
<span class="sd">    - Inverse transform: ∂u/∂x = IFFT(ik * û_k)</span>

<span class="sd">    For non-periodic functions, Fourier continuation extends the function to</span>
<span class="sd">    an extended domain (e.g. [0, 2π] → [0, 2π + 2π*additional_pts/n]) on which</span>
<span class="sd">    the function is periodic.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # 1D Fourier derivatives</span>
<span class="sd">    &gt;&gt;&gt; x = torch.linspace(0, 2*torch.pi, 100)</span>
<span class="sd">    &gt;&gt;&gt; u = torch.sin(x)</span>
<span class="sd">    &gt;&gt;&gt; fd1d = FourierDiff(dim=1, L=2*torch.pi, use_fc=False)</span>
<span class="sd">    &gt;&gt;&gt; du_dx = fd1d.dx(u)  # First derivative</span>
<span class="sd">    &gt;&gt;&gt; d2u_dx2 = fd1d.dx(u, order=2)  # Second derivative</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # 2D Fourier derivatives</span>
<span class="sd">    &gt;&gt;&gt; fd2d = FourierDiff(dim=2, L=(2*torch.pi, 2*torch.pi), use_fc=False)</span>
<span class="sd">    &gt;&gt;&gt; x = torch.linspace(0, 2*torch.pi, 50)</span>
<span class="sd">    &gt;&gt;&gt; y = torch.linspace(0, 2*torch.pi, 50)</span>
<span class="sd">    &gt;&gt;&gt; X, Y = torch.meshgrid(x, y, indexing=&#39;ij&#39;)</span>
<span class="sd">    &gt;&gt;&gt; u = torch.sin(X) * torch.cos(Y)</span>
<span class="sd">    &gt;&gt;&gt; du_dx = fd2d.dx(u)</span>
<span class="sd">    &gt;&gt;&gt; du_dy = fd2d.dy(u)</span>
<span class="sd">    &gt;&gt;&gt; grad = fd2d.gradient(u)  # Returns [du_dx, du_dy]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # 3D Fourier derivatives</span>
<span class="sd">    &gt;&gt;&gt; fd3d = FourierDiff(dim=3, L=(2*torch.pi, 2*torch.pi, 2*torch.pi), use_fc=False)</span>
<span class="sd">    &gt;&gt;&gt; x = torch.linspace(0, 2*torch.pi, 20)</span>
<span class="sd">    &gt;&gt;&gt; y = torch.linspace(0, 2*torch.pi, 20)</span>
<span class="sd">    &gt;&gt;&gt; z = torch.linspace(0, 2*torch.pi, 20)</span>
<span class="sd">    &gt;&gt;&gt; X, Y, Z = torch.meshgrid(x, y, z, indexing=&#39;ij&#39;)</span>
<span class="sd">    &gt;&gt;&gt; u = torch.sin(X) * torch.cos(Y) * torch.sin(Z)  # 3D scalar field</span>
<span class="sd">    &gt;&gt;&gt; du_dx = fd3d.dx(u)</span>
<span class="sd">    &gt;&gt;&gt; du_dy = fd3d.dy(u)</span>
<span class="sd">    &gt;&gt;&gt; du_dz = fd3d.dz(u)</span>
<span class="sd">    &gt;&gt;&gt; laplacian = fd3d.laplacian(u)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Vector field operations</span>
<span class="sd">    &gt;&gt;&gt; vx = torch.sin(X) * torch.cos(Y) * torch.sin(Z)</span>
<span class="sd">    &gt;&gt;&gt; vy = torch.cos(X) * torch.sin(Y) * torch.cos(Z)</span>
<span class="sd">    &gt;&gt;&gt; vz = torch.sin(X) * torch.sin(Y) * torch.cos(Z)</span>
<span class="sd">    &gt;&gt;&gt; v = torch.stack([vx, vy, vz], dim=-4)</span>
<span class="sd">    &gt;&gt;&gt; div_v = fd3d.divergence(v)</span>
<span class="sd">    &gt;&gt;&gt; curl_v = fd3d.curl(v)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">,</span>
        <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_fc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fc_degree</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">fc_n_additional_pts</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">low_pass_filter_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the FourierDiff class for computing Fourier derivatives.</span>

<span class="sd">        See class docstring for detailed parameter descriptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if dim is valid</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dim must be 1, 2, or 3&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="c1"># Set default L based on dimension</span>
        <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="p">,)</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">D, L must be a single float or tuple with </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> elements&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">L</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="o">=</span> <span class="n">use_fc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc_degree</span> <span class="o">=</span> <span class="n">fc_degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span> <span class="o">=</span> <span class="n">fc_n_additional_pts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span> <span class="o">=</span> <span class="n">low_pass_filter_ratio</span>

        <span class="c1"># Initialize FC class if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Legendre&quot;</span><span class="p">,</span> <span class="s2">&quot;Gram&quot;</span><span class="p">]:</span>
            <span class="n">FC_class</span> <span class="o">=</span> <span class="n">FCLegendre</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="o">==</span> <span class="s2">&quot;Legendre&quot;</span> <span class="k">else</span> <span class="n">FCGram</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="o">=</span> <span class="n">FC_class</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_degree</span><span class="p">,</span> <span class="n">n_additional_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span><span class="p">)</span>

<div class="viewcode-block" id="FourierDiff.compute_multiple_derivatives">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.compute_multiple_derivatives">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_multiple_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute multiple derivatives in a single FFT/IFFT call for better performance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input tensor.</span>
<span class="sd">        derivatives : list</span>
<span class="sd">            List of derivative specifications:</span>
<span class="sd">            - 1D: list of int (orders)</span>
<span class="sd">            - 2D: list of tuples (order_x, order_y)</span>
<span class="sd">            - 3D: list of tuples (order_x, order_y, order_z)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of torch.Tensor</span>
<span class="sd">            List of computed derivatives in the same order as derivatives input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierDiff.derivative">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.derivative">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Fourier derivative of a given tensor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input tensor</span>
<span class="sd">        order : tuple</span>
<span class="sd">            Derivative orders:</span>
<span class="sd">            - 1D: (order_x,)</span>
<span class="sd">            - 2D: (order_x, order_y)</span>
<span class="sd">            - 3D: (order_x, order_y, order_z)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The derivative of the input tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">D, order must be a tuple with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> elements&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[</span><span class="n">order</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[</span><span class="n">order</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="FourierDiff.partial">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.partial">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute partial Fourier derivative along a specific direction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : torch.Tensor</span>
<span class="sd">            Input tensor</span>
<span class="sd">        direction : str, optional</span>
<span class="sd">            Direction along which to compute the derivative, by default &#39;x&#39;</span>
<span class="sd">            Options: &#39;x&#39;, &#39;y&#39; (2D/3D only), &#39;z&#39; (3D only)</span>
<span class="sd">        order : int, optional</span>
<span class="sd">            Order of the derivative, by default 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            The partial derivative of the input tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid direction &#39;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&#39; for dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="FourierDiff.dx">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.dx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute derivative with respect to x.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dx_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierDiff.dy">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.dy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute derivative with respect to y (2D/3D only).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dy method only available for 2D and 3D&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dy_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierDiff.dz">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.dz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute derivative with respect to z (3D only).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dz method only available for 3D&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dz_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierDiff.laplacian">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.laplacian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">laplacian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Laplacian ∇²f.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierDiff.gradient">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the gradient ∇f (returns vector field).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">(</span><span class="n">u</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">4</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierDiff.divergence">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.divergence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">divergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the divergence ∇·u (for vector fields).&quot;&quot;&quot;</span>
        <span class="n">expected_dims</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expected_dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">D, input must have </span><span class="si">{</span><span class="n">expected_dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">]</span><span class="si">}</span><span class="s2"> components in the vector dimension&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span></div>

    
<div class="viewcode-block" id="FourierDiff.curl">
<a class="viewcode-back" href="../../../modules/generated/neuralop.losses.differentiation.FourierDiff.html#neuralop.losses.differentiation.FourierDiff.curl">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">curl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the curl ∇×u (for vector fields, 2D/3D only).&quot;&quot;&quot;</span>
        <span class="c1"># Check input dimensions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;curl not defined for 1D&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For 2D, input must have 2 components in the vector dimension&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For 3D, input must have 3 components in the vector dimension&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># In 2D: ∂v/∂x - ∂u/∂y where u = (u,v) is a 2D vector field</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># In 3D, ∇×u = (∂w/∂y - ∂v/∂z, ∂u/∂z - ∂w/∂x, ∂v/∂x - ∂u/∂y) where u = (u,v,w) is a 3D vector field</span>
            <span class="n">curl_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span>  <span class="c1"># ∂w/∂y - ∂v/∂z</span>
            <span class="n">curl_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span>  <span class="c1"># ∂u/∂z - ∂w/∂x  </span>
            <span class="n">curl_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span>  <span class="c1"># ∂v/∂x - ∂u/∂y</span>
            
            <span class="c1"># Stack the components into a 3D vector field</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">curl_x</span><span class="p">,</span> <span class="n">curl_y</span><span class="p">,</span> <span class="n">curl_z</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">4</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_multiple_derivatives_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">orders</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;1D multiple derivatives computation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input tensor u is None&quot;</span><span class="p">)</span>

        <span class="n">L_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">u_clone</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="c1"># Apply Fourier continuation if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u_clone</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">u_clone</span> <span class="o">=</span> <span class="n">FC</span><span class="p">(</span><span class="n">u_clone</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">L_x</span> <span class="o">*=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span>

        <span class="c1"># Update grid parameters after extension</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">u_clone</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">L_x</span> <span class="o">/</span> <span class="n">nx</span>

        <span class="c1"># FFT</span>
        <span class="n">u_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">u_clone</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Frequency array</span>
        <span class="n">k_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">u_h</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Apply low-pass filter if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">u_h</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span><span class="p">)</span>
            <span class="n">u_h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute derivatives</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">:</span>
            <span class="n">derivative_u_h</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k_x</span><span class="p">)</span> <span class="o">**</span> <span class="n">order</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_h</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">derivative_u_h</span><span class="p">)</span>

        <span class="n">derivatives_ft</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">derivatives_real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">derivatives_ft</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">nx</span><span class="p">)</span>

        <span class="c1"># Crop result if Fourier continuation was used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">derivatives_real</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">derivatives_real</span> <span class="o">=</span> <span class="n">FC</span><span class="o">.</span><span class="n">restrict</span><span class="p">(</span><span class="n">derivatives_real</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">derivatives_real</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orders</span><span class="p">))]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;1D derivative with respect to x.&quot;&quot;&quot;</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[</span><span class="n">order</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_multiple_derivatives_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2D multiple derivatives computation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input tensor u is None&quot;</span><span class="p">)</span>

        <span class="n">L_x</span><span class="p">,</span> <span class="n">L_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">u_clone</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="c1"># Apply Fourier continuation if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u_clone</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">u_clone</span> <span class="o">=</span> <span class="n">FC</span><span class="p">(</span><span class="n">u_clone</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">L_x</span> <span class="o">*=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span>
            <span class="n">L_y</span> <span class="o">*=</span> <span class="p">(</span><span class="n">ny</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span><span class="p">)</span> <span class="o">/</span> <span class="n">ny</span>

        <span class="c1"># Update grid parameters after extension</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">u_clone</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">u_clone</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">L_x</span> <span class="o">/</span> <span class="n">nx</span><span class="p">,</span> <span class="n">L_y</span> <span class="o">/</span> <span class="n">ny</span>

        <span class="c1"># 2D FFT</span>
        <span class="n">u_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">u_clone</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Frequency arrays</span>
        <span class="n">k_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">u_h</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">k_y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dy</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">u_h</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Create frequency meshgrid</span>
        <span class="n">KX</span><span class="p">,</span> <span class="n">KY</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">k_x</span><span class="p">,</span> <span class="n">k_y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>

        <span class="c1"># Apply low-pass filter if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span><span class="p">)</span>
            <span class="n">cutoff_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ny</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span><span class="p">)</span>
            <span class="n">u_h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cutoff_y</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">u_h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="n">cutoff_x</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute derivatives</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">order_x</span><span class="p">,</span> <span class="n">order_y</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">:</span>
            <span class="c1"># Expand meshgrid tensors for proper broadcasting</span>
            <span class="n">KX_expanded</span> <span class="o">=</span> <span class="n">KX</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u_h</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">KY_expanded</span> <span class="o">=</span> <span class="n">KY</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u_h</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
            <span class="n">derivative_u_h</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">KX_expanded</span><span class="p">)</span> <span class="o">**</span> <span class="n">order_x</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">KY_expanded</span><span class="p">)</span> <span class="o">**</span> <span class="n">order_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_h</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">derivative_u_h</span><span class="p">)</span>

        <span class="n">derivatives_ft</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">derivatives_real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">derivatives_ft</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># Crop result if Fourier continuation was used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">derivatives_real</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">derivatives_real</span> <span class="o">=</span> <span class="n">FC</span><span class="o">.</span><span class="n">restrict</span><span class="p">(</span><span class="n">derivatives_real</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">derivatives_real</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">derivatives</span><span class="p">))]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2D derivative with respect to x.&quot;&quot;&quot;</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[(</span><span class="n">order</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;2D derivative with respect to y.&quot;&quot;&quot;</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_multiple_derivatives_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">derivatives</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D multiple derivatives computation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input tensor u is None&quot;</span><span class="p">)</span>

        <span class="n">L_x</span><span class="p">,</span> <span class="n">L_y</span><span class="p">,</span> <span class="n">L_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">u_clone</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="c1"># Apply Fourier continuation if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u_clone</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">u_clone</span> <span class="o">=</span> <span class="n">FC</span><span class="p">(</span><span class="n">u_clone</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">L_x</span> <span class="o">*=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span>
            <span class="n">L_y</span> <span class="o">*=</span> <span class="p">(</span><span class="n">ny</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span><span class="p">)</span> <span class="o">/</span> <span class="n">ny</span>
            <span class="n">L_z</span> <span class="o">*=</span> <span class="p">(</span><span class="n">nz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_n_additional_pts</span><span class="p">)</span> <span class="o">/</span> <span class="n">nz</span>

        <span class="c1"># Update grid parameters after extension</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">u_clone</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">u_clone</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">u_clone</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">L_x</span> <span class="o">/</span> <span class="n">nx</span><span class="p">,</span> <span class="n">L_y</span> <span class="o">/</span> <span class="n">ny</span><span class="p">,</span> <span class="n">L_z</span> <span class="o">/</span> <span class="n">nz</span>

        <span class="c1"># 3D FFT</span>
        <span class="n">u_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">u_clone</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Frequency arrays</span>
        <span class="n">k_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">u_h</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">k_y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dy</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">u_h</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">k_z</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">nz</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dz</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">u_h</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Create frequency meshgrid</span>
        <span class="n">KX</span><span class="p">,</span> <span class="n">KY</span><span class="p">,</span> <span class="n">KZ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">k_x</span><span class="p">,</span> <span class="n">k_y</span><span class="p">,</span> <span class="n">k_z</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>

        <span class="c1"># Apply low-pass filter if specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span><span class="p">)</span>
            <span class="n">cutoff_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ny</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span><span class="p">)</span>
            <span class="n">cutoff_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_pass_filter_ratio</span><span class="p">)</span>
            <span class="n">u_h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">cutoff_y</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">u_h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="n">cutoff_x</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">u_h</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">cutoff_z</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Compute derivatives</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">order_x</span><span class="p">,</span> <span class="n">order_y</span><span class="p">,</span> <span class="n">order_z</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">:</span>
            <span class="c1"># Expand meshgrid tensors for proper broadcasting</span>
            <span class="n">KX_expanded</span> <span class="o">=</span> <span class="n">KX</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u_h</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">KY_expanded</span> <span class="o">=</span> <span class="n">KY</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u_h</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">KZ_expanded</span> <span class="o">=</span> <span class="n">KZ</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">u_h</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
            <span class="n">derivative_u_h</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">KX_expanded</span><span class="p">)</span> <span class="o">**</span> <span class="n">order_x</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">KY_expanded</span><span class="p">)</span> <span class="o">**</span> <span class="n">order_y</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">KZ_expanded</span><span class="p">)</span> <span class="o">**</span> <span class="n">order_z</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_h</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">derivative_u_h</span><span class="p">)</span>

        <span class="n">derivatives_ft</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">derivatives_real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">derivatives_ft</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># Crop result if Fourier continuation was used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_fc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">derivatives_real</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">derivatives_real</span> <span class="o">=</span> <span class="n">FC</span><span class="o">.</span><span class="n">restrict</span><span class="p">(</span><span class="n">derivatives_real</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">derivatives_real</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">derivatives</span><span class="p">))]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dx_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D derivative with respect to x.&quot;&quot;&quot;</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[(</span><span class="n">order</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dy_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D derivative with respect to y.&quot;&quot;&quot;</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_dz_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D derivative with respect to z.&quot;&quot;&quot;</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_multiple_derivatives_3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">derivatives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

</pre></div>

      </div>

      

        <footer class="footer">
    <div class="content has-text-centered">
        <div class="block">
          &copy; Copyright 2025, Jean Kossaifi, David Pitt, Nikola Kovachki, Zongyi Li and Anima Anandkumar.<br/>
        </div>
    </div>
  </footer>

    </div>

  </div>  

	

  </div>  
  </div> 

  
  <script>
    function toggle_sidebar() {
        var element = document.getElementById("sidebar");
        var container = document.getElementById("column-container");
        var localtoccolumn = document.getElementById("localtoc-column");
        element.classList.toggle("hide-tablet");
        element.classList.toggle("is-hidden-mobile");
        container.classList.toggle("sidemenu-hidden");
        localtoccolumn.classList.toggle("is-one-fifth-widescreen");
        localtoccolumn.classList.toggle("is-2-desktop");
        localtoccolumn.classList.toggle("is-3-desktop");
    }
  </script> 



  </body>
</html>